*&---------------------------------------------------------------------*
*& Report  Z_WIP_S20                                                   *
*&                                                                     *
*&---------------------------------------------------------------------*
*&                                                                     *
*&                                                                     *
*&---------------------------------------------------------------------*
*
*
* 11/2/2007
* Copy from z_wip_clear and regenerated by IG.MOON
*
*
*
*
*
*The report uses three parameters : Viz the assembly, flags 'test'
*as well as the flag 'CHKNCAN'.
*The report does a small check and creates warning messages like
*'Confirmation does not exist for order'->it means confirmation
*archieved'Is this order final confirmed?' -> it means last
*confirmation is not
*a GR confirmation. So the order has
*to be checked manually whether it is really final confirmed
*
*If the selection flag CHKMAN is set and any of these warning messages
*appears in the protocol then the report will not proceed with the CPZP
*updation even if the "Test" flag is not set.
*So if you want to correct the WIP then you should clear both selection
*flags.


REPORT  z_wip_clear  LINE-SIZE 250.                              .
TABLES: ppc_head, ppc_conf_act_var,ppc_ord_inf,qrp002,
        ppc_act, ppc_mat_det, ppc_mat.


SELECT-OPTIONS:
so_prod FOR ppc_ord_inf-materialnr NO INTERVALS.
PARAMETER: p_test(1) DEFAULT 'X',
           chkncan(1) DEFAULT 'X'.


DATA: lt_hdr LIKE ppc_head OCCURS 0,
      ls_hdr LIKE ppc_head,
      lt_ord LIKE ppc_ord_inf OCCURS 0,
      ls_ord LIKE ppc_ord_inf,
      ls_cpzp LIKE cpzp,
      ls_cpzp_tmp LIKE cpzp,
      lt_cpzp LIKE cpzp OCCURS 0,
      lt_cpzp_tmp LIKE cpzp OCCURS 0,
      l_accassobj TYPE ppc_accassobj_int,
      lf_aufnr TYPE aufnr,
      lf_objnr TYPE j_objnr,
      lf_pkosa_error TYPE c,
      l_d TYPE ist_menge,
      l_mng1 TYPE ist_menge,
      l_mng2 TYPE ist_menge,
      l_problem(1).

CLEAR l_problem.
IF p_test IS INITIAL.
*--> Set lock to prevent ppc postings
  PERFORM conf_mat_enqueue(saplppc1pr).
  CALL FUNCTION 'ENQUEUE_E_PPC_HEAD_TIMS'
       EXPORTING
            mode_ppc_head  = 'E'
            mandt          = sy-mandt
            _scope         = '3'
       EXCEPTIONS
            foreign_lock   = 1
            system_failure = 2
            OTHERS         = 3.
ENDIF.

SELECT * FROM ppc_ord_inf INTO TABLE lt_ord
WHERE materialnr IN so_prod.

* check last confirmation.

CHECK NOT lt_ord[] IS INITIAL.

SELECT * FROM ppc_head INTO TABLE lt_hdr
FOR ALL ENTRIES IN lt_ord
WHERE orderid = lt_ord-orderid
AND flg_info_dest NE '3'.  "exclude PPCVAR

* by ig.moon 01/22/08 {
PERFORM filter_lt_hdr TABLES lt_hdr lt_ord.
* }

*SORT LT_HDR BY ORDERID CONFTIME.
SORT lt_hdr BY orderid  ASCENDING
               conftime DESCENDING .

LOOP AT lt_ord INTO ls_ord.

  READ TABLE lt_hdr INTO ls_hdr WITH KEY orderid = ls_ord-orderid
       BINARY SEARCH.

  IF sy-subrc EQ 0.
    IF ls_hdr-flg_gr_head IS INITIAL.
      WRITE: /1 'Is this order final confirmed?',ls_ord-ordernr.
      l_problem = 'X'.
    ENDIF.
  ELSE.
    WRITE: /1 'Confirmation does not exist for order', ls_ord-ordernr.
    l_problem = 'X'.
  ENDIF.
* Checking open processes
  LOOP AT lt_hdr INTO ls_hdr WHERE orderid = ls_ord-orderid.
*  is there any open process
    IF ls_hdr-flg_synch EQ ' ' OR ls_hdr-flg_synch = 'B' OR
       ls_hdr-flg_asynch EQ ' ' OR ls_hdr-flg_asynch = 'B' OR
       ls_hdr-flg_asynch_a EQ ' ' OR ls_hdr-flg_asynch_a = 'B'.
      WRITE: /1 'Order has still open process', ls_ord-ordernr,
                                                ls_hdr-headid.
      l_problem = 'A'.
    ENDIF.
    DELETE lt_hdr.
  ENDLOOP.
ENDLOOP.

ULINE.

IF l_problem = 'A'.
  WRITE: /1
       'ABORT! Please finish first the open confirmations.(Tr.PPCGO)'.
  EXIT.
ENDIF.

IF NOT l_problem IS INITIAL AND
   NOT chkncan IS INITIAL.
  EXIT.
ENDIF.

FREE lt_hdr.

SORT lt_ord BY accassobj.
DELETE ADJACENT DUPLICATES FROM lt_ord COMPARING accassobj.


LOOP AT lt_ord INTO ls_ord.
  CLEAR lt_cpzp.
  REFRESH lt_cpzp.


  l_accassobj = ls_ord-accassobj.
*   get the OBJNR
  PERFORM objnr_get(saplqrprp) USING    l_accassobj
                    CHANGING lf_aufnr
                             lf_objnr
                             lf_pkosa_error.


*ISTMN
*GMPER
*gmsum
  SELECT * FROM cpzp INTO TABLE lt_cpzp
  WHERE objnr = lf_objnr.

  LOOP AT lt_cpzp INTO ls_cpzp.
    IF ls_cpzp-f_objnr NE ls_cpzp_tmp-f_objnr.
      CLEAR l_d.
    ENDIF.

    ls_cpzp_tmp = ls_cpzp.
    l_mng1 = ls_cpzp-istmn - ls_cpzp-gmsum .
    l_mng2 = ls_cpzp-istmn + l_d.

* check the period
    IF ls_cpzp-istmn < 0 AND ls_cpzp-gmsum = 0.
* 0.160- 0.000   0.000
      CLEAR ls_cpzp_tmp-istmn.                  "=>
      CLEAR ls_cpzp_tmp-gmper.

    ELSEIF ls_cpzp-istmn  = 0 AND
           ls_cpzp-gmper = 0 AND
           ls_cpzp-gmsum NE 0.                  "=>
*  0.000  0   1.000
      CLEAR ls_cpzp_tmp-gmsum.

    ELSEIF l_mng1 NE 0.                         "=>
*( ls_cpzp-istmn - ls_cpzp-gmsum ) ne 0.      "=>
* 7.200  7.200   7.360

      IF ls_cpzp-istmn = ls_cpzp-gmper.
        ls_cpzp_tmp-gmsum = ls_cpzp-istmn.      "=>

        l_d = ls_cpzp-gmsum - ls_cpzp-istmn.

      ELSEIF NOT l_d IS INITIAL AND
      l_mng2 = ls_cpzp-gmsum.                   "=>
*   ( ls_cpzp-istmn + l_d ) = ls_cpzp-gmsum.  "=>
* 3.040  3.200   3.200

        ls_cpzp_tmp-istmn = ls_cpzp-gmper.
        ls_cpzp_tmp-gmsum = ls_cpzp-gmper.

      ELSE.
* all other cases
        ls_cpzp_tmp-gmsum = ls_cpzp-gmper.
        ls_cpzp_tmp-istmn = ls_cpzp-gmper.

      ENDIF.

    ELSE.
* all other cases
      ls_cpzp_tmp-gmsum = ls_cpzp-gmper.
      ls_cpzp_tmp-istmn = ls_cpzp-gmper.

    ENDIF.


    IF ls_cpzp_tmp NE ls_cpzp.
      WRITE: /1 'OBJNR', ls_cpzp-objnr, 'F_OBJ', ls_cpzp-f_objnr,
          'Per', ls_cpzp-gjper, 'IST', ls_cpzp-istmn, ls_cpzp_tmp-istmn,
      'GMP', ls_cpzp-gmper, ls_cpzp_tmp-gmper,
      'SUM', ls_cpzp-gmsum, ls_cpzp_tmp-gmsum.

      APPEND ls_cpzp_tmp TO lt_cpzp_tmp.
    ENDIF.
  ENDLOOP.

ENDLOOP.


IF p_test IS INITIAL.
  UPDATE cpzp FROM TABLE lt_cpzp_tmp.
  COMMIT WORK.
*--> dequeue
  PERFORM conf_mat_dequeue(saplppc1pr).
  CALL FUNCTION 'DEQUEUE_E_PPC_HEAD_TIMS'
       EXPORTING
            mode_ppc_head = 'E'
            mandt         = sy-mandt
            _scope        = '3'.
ENDIF.
*&---------------------------------------------------------------------*
*&      Form  filter_lt_hdr
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LT_HDR  text
*----------------------------------------------------------------------*
FORM filter_lt_hdr TABLES p_lt_hdr STRUCTURE ppc_head
                          p_lt_ord STRUCTURE ppc_ord_inf.

  DATA : BEGIN OF lt_order_sum OCCURS 0,
            orderid	TYPE ppc_orderid,
            confquant TYPE ppc_headconfquant,
            flg_reversal	TYPE ppc_flg_rev,
         END OF lt_order_sum.
  DATA $ix LIKE sy-tabix.

  LOOP AT p_lt_hdr INTO ls_hdr.
    MOVE-CORRESPONDING ls_hdr TO lt_order_sum.

*    IF ls_hdr-flg_synch EQ ' ' OR ls_hdr-flg_synch = 'B' OR
*       ls_hdr-flg_asynch EQ ' ' OR ls_hdr-flg_asynch = 'B' OR
*       ls_hdr-flg_asynch_a EQ ' ' OR ls_hdr-flg_asynch_a = 'B'.
*      APPEND lt_order_sum.
*      CONTINUE.
*    ENDIF.

    IF lt_order_sum-flg_reversal EQ 'X'.
      lt_order_sum-confquant = -1 * lt_order_sum-confquant.
    ENDIF.
    CLEAR lt_order_sum-flg_reversal.
    COLLECT lt_order_sum.
    CLEAR lt_order_sum.
  ENDLOOP.
  DELETE lt_order_sum WHERE confquant <= 0.
  SORT lt_order_sum BY orderid.

  LOOP AT p_lt_ord INTO ls_ord.
    $ix = sy-tabix.
*    if ls_ord-orderid eq '0001922609'.
*      break-point.
*    endif.
    READ TABLE lt_order_sum WITH KEY orderid = ls_ord-orderid
                            BINARY SEARCH.
    IF sy-subrc NE 0.
      DELETE p_lt_ord INDEX $ix.
    ENDIF.
  ENDLOOP.

ENDFORM.                    " filter_lt_hdr
